# 第四階段：課堂教學流程建議

## 📋 課前準備（5分鐘）

### 教師準備
- [ ] 複習第三階段的多層繼承
- [ ] 準備介面 vs 抽象類別對照表
- [ ] 準備白板：畫介面關係圖
- [ ] 測試第四階段程式碼

### 學生準備
- [ ] 完成第三階段作業
- [ ] 思考「聖騎士」的設計問題
- [ ] 複習單一繼承的限制

---

## 🎯 教學流程（50分鐘課程）

### Part 1: 引入問題 - 單一繼承的限制（10分鐘）

#### 步驟 1: 提出設計挑戰
「我們要設計一個『聖騎士』：
- 是近戰角色（需要繼承 MeleeRole）
- 會防禦（像持盾劍士）
- 會治療（像魔法師）

用現有的繼承結構，該怎麼做？」

#### 步驟 2: 讓學生嘗試設計
**給 3 分鐘討論**

**可能的回答：**
1. 繼承 MeleeRole，自己寫防禦和治療
2. 創建一個新的父類別
3. 多重繼承（Java 不支援！）

#### 步驟 3: 指出問題
**在白板展示：**
```java
// ❌ 方案 1：程式碼重複
public class Paladin extends MeleeRole {
    public void defend() { ... }  // 和 ShieldSwordsMan 重複
    public void heal() { ... }    // 和 Magician 重複
}

// ❌ 方案 2：Java 不支援
public class Paladin extends MeleeRole, DefenseClass {
    // 編譯錯誤！
}
```

**結論：** 我們需要一個新的機制！

---

### Part 2: 引入介面解決方案（15分鐘）

#### 步驟 1: 介紹介面概念

**在白板寫：**
```
抽象類別：描述「是什麼」
- Paladin "是" MeleeRole

介面：描述「能做什麼」
- Paladin "能" 防禦
- Paladin "能" 治療
```

#### 步驟 2: 展示介面語法

```java
// 定義介面
public interface Defendable {
    void defend();
    int getDefenseCapacity();
}

// 實作介面
public class Paladin extends MeleeRole 
                      implements Defendable, Healable {
    // 同時繼承和實作！
}
```

**關鍵重點：**
- 用 `interface` 關鍵字定義
- 用 `implements` 關鍵字實作
- 可以實作多個介面（逗號分隔）
- 必須實作所有抽象方法

#### 步驟 3: 對比表

**在白板畫表格：**

| 特性 | 抽象類別 | 介面 |
|-----|---------|------|
| 數量 | 只能繼承 1 個 | 可實作多個 |
| 用途 | 是什麼 | 能做什麼 |
| 關鍵字 | extends | implements |
| 建構子 | 可以有 | 不能有 |
| 欄位 | 可以有 | 只能有常數 |

---

### Part 3: 實作與展示（15分鐘）

#### 步驟 1: 帶學生實作 Defendable

```java
public interface Defendable {
    void defend();
    int getDefenseCapacity();
    
    // 預設方法
    default boolean canDefend() {
        return getDefenseCapacity() > 0;
    }
}
```

**解釋預設方法：**
- 介面可以有預設實作（Java 8+）
- 子類別可選擇性覆寫
- 讓介面更有彈性

#### 步驟 2: 讓學生實作 ShieldSwordsMan

**給 5 分鐘：**
「請讓 ShieldSwordsMan 實作 Defendable 介面」

**檢查重點：**
- 是否加上 `implements Defendable`
- 是否實作 `defend()` 和 `getDefenseCapacity()`
- 是否加上 `@Override`

#### 步驟 3: 展示 Paladin（多重介面）

```java
public class Paladin extends MeleeRole 
                      implements Defendable, Healable {
    // 必須實作兩個介面的所有方法
    
    @Override
    public void defend() { ... }
    
    @Override
    public void heal(Role target) { ... }
}
```

**強調：**
- 同時實作兩個介面！
- 這就是介面的強大之處
- 突破單一繼承限制

---

### Part 4: 統整與應用（10分鐘）

#### 步驟 1: 執行程式展示

**展示輸出：**
```
【可防禦角色】
✅ 持盾劍士 - 防禦力：10
✅ 聖騎士 - 防禦力：12

【可治療角色】
✅ 光明法師 - 治療力：10
✅ 聖騎士 - 治療力：12

【多重能力角色】
⭐ 聖騎士 - 同時擁有防禦和治療能力！
```

**重點：**
- 可以用 `instanceof` 檢查介面
- 介面讓角色分類更清晰
- 容易找到有特定能力的角色

#### 步驟 2: 設計原則總結

**在白板寫：**
```
何時用抽象類別？
- 定義「是什麼」
- 共享程式碼
- 建立類別階層

何時用介面？
- 定義「能做什麼」
- 多個類別需要相同能力
- 突破單一繼承限制
```

#### 步驟 3: 討論問題

**提問：**
1. 「為什麼不把防禦能力直接放在 MeleeRole？」
   - 不是所有近戰角色都會防禦

2. 「介面可以有實例變數嗎？」
   - 不行，只能有常數

3. 「一個類別最多可以實作幾個介面？」
   - 理論上無限，但實務上不要太多

---

## 💡 互動技巧

### 提問策略

1. **對比式提問**
   「抽象類別和介面的差異是什麼？」

2. **情境式提問**
   「如果要設計會飛的角色，該用抽象類別還是介面？」

3. **設計式提問**
   「為什麼 Defendable 要設計成介面而不是抽象類別？」

### 視覺化教學

**畫圖說明：**
```
        Paladin
         /  \
    繼承/    \實作
       /      \
  MeleeRole  Defendable
              Healable
```

---

## 📝 課後作業

### 基礎作業：實作 Priest（牧師）
1. 繼承 RangedRole
2. 實作 Healable 介面
3. 不實作 Defendable（牧師不擅防禦）

### 進階作業：設計 Stealthy 介面
1. 定義隱身能力介面
2. 讓 Assassin（刺客）實作
3. 新增預設方法 `getStealthBonus()`

### 挑戰作業：Bard（吟遊詩人）
1. 設計新介面 `Buffable`（增益能力）
2. Bard 實作 Buffable 和 Healable
3. 展示一個角色實作三個介面

---

## 🎓 評量重點

### 知識面（40%）
- 能解釋介面與抽象類別的差異
- 能說明為什麼需要介面
- 理解多重介面實作
- 了解預設方法的用途

### 技能面（40%）
- 能正確定義介面
- 能實作介面的所有方法
- 能判斷該用抽象類別還是介面
- 能使用 instanceof 檢查介面

### 應用面（20%）
- 能設計合理的介面
- 能解決單一繼承的限制問題
- 能整合抽象類別與介面

---

## 🔄 課程總結

**四個階段回顧：**

```
第一階段：抽象方法
- 為什麼需要抽象方法
- 強制子類別實作

第二階段：具體方法 + 抽象方法
- 共通邏輯 vs 個別差異
- Template Method Pattern

第三階段：多層繼承
- 中間抽象類別
- 類別階層設計

第四階段：介面 ✅
- 突破單一繼承限制
- 組合能力
- 抽象類別 + 介面
```

---

## ⏰ 時間分配

| 階段 | 時間 | 重點 |
|-----|------|------|
| 引入問題 | 10分鐘 | 單一繼承限制 |
| 介面解決方案 | 15分鐘 | 介面概念與語法 |
| 實作展示 | 15分鐘 | 多重介面實作 |
| 統整應用 | 10分鐘 | 設計原則 |

---

## 📚 補充說明

### 實務應用

**Java 標準庫的介面：**
- `Comparable`：可比較
- `Serializable`：可序列化
- `Runnable`：可執行
- `Iterable`：可迭代

### 設計模式

這個設計體現了：
- **策略模式**（Strategy Pattern）
- **能力模式**（Capability Pattern）
- **組合優於繼承**

---

## 🎯 教學技巧

### 1. 先提問題，再給答案
讓學生自己發現單一繼承的限制

### 2. 對比教學
不斷對比抽象類別與介面

### 3. 實例驅動
用具體的遊戲角色幫助理解

### 4. 漸進式複雜度
從單一介面到多重介面

---

## 💡 常見學生困惑

### 困惑 1：為什麼不全部用介面？
**解答：** 介面不能有實例變數，不能共享程式碼。抽象類別更適合建立類別階層。

### 困惑 2：預設方法是必要的嗎？
**解答：** 不是必要，但很有用。它讓介面更有彈性，也保持向後相容性。

### 困惑 3：介面可以繼承介面嗎？
**解答：** 可以！介面可以用 `extends` 繼承其他介面。

---

**教學提示：**
- 用生活例子解釋（人「是」生物，「能」游泳）
- 強調「is-a」vs「can-do」的概念
- 多展示實際程式碼執行結果
- 鼓勵學生設計自己的介面
