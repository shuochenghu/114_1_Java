# 第二階段：課堂教學流程建議

## 📋 課前準備（5分鐘）

### 教師準備
- [ ] 複習第一階段的抽象方法概念
- [ ] 準備白板圖示：共通邏輯 vs 個別差異
- [ ] 準備 DRY 原則的說明
- [ ] 測試第二階段程式碼

### 學生準備
- [ ] 完成第一階段作業
- [ ] 複習抽象方法的概念
- [ ] 思考「為什麼要用抽象類別」

---

## 🎯 教學流程（50分鐘課程）

### Part 1: 引入問題 - 重複程式碼（10分鐘）

#### 步驟 1: 回顧第一階段
「上週我們學會了抽象方法，今天要解決一個新問題：如何避免重複的程式碼？」

#### 步驟 2: 展示問題
假設每個角色受傷時：
1. 扣除生命值
2. 顯示訊息
3. 檢查死亡

如果每個子類別都自己寫，會有什麼問題？

#### 步驟 3: 學生討論
讓學生發現：程式碼重複、難以維護、容易不一致

---

### Part 2: 引入具體方法（15分鐘）

#### 步驟 1: 介紹「共通邏輯」vs「個別差異」

```
受傷流程：
1-3: 所有角色相同 → 具體方法
4: 每個角色不同 → 抽象方法
```

#### 步驟 2: 展示 takeDamage() 設計

```java
public void takeDamage(int damage) {
    this.health -= damage;  // 共通
    System.out.println("受傷");  // 共通
    if (!isAlive()) {
        onDeath();  // 個別差異
    }
}
```

#### 步驟 3: 強調關鍵
「具體方法可以呼叫抽象方法！」

---

### Part 3: 實作練習（15分鐘）

#### 讓學生實作：
1. `onDeath()` - 劍士和魔法師的死亡效果
2. `prepareBattle()` - 戰前準備
3. `afterBattle()` - 戰後行為

#### 巡視重點：
- 是否加上 @Override
- 是否有創意設計
- 訊息是否清楚

---

### Part 4: 討論與總結（10分鐘）

#### 對照表討論：

| 方法 | 類型 | 原因 |
|-----|------|------|
| takeDamage() | 具體 | 流程相同 |
| onDeath() | 抽象 | 效果不同 |
| prepareBattle() | 抽象 | 準備方式不同 |

#### 設計原則：
- DRY 原則
- Template Method Pattern
- 共通邏輯 vs 個別差異

---

## 💡 互動技巧

### 提問策略
1. 「為什麼 takeDamage() 是具體方法？」
2. 「什麼是共通邏輯？什麼是個別差異？」
3. 「如果新增升級功能，應該用哪種方法？」

### 常見問題
**Q: 具體方法可以被覆寫嗎？**
A: 可以，但通常不需要。

**Q: 為什麼要用 abstract？**
A: 這是保護機制，確保類別完整。

---

## 📝 課後作業

### 基礎作業：實作升級系統
1. levelUp() 具體方法
2. onLevelUp() 抽象方法
3. 各角色實作特殊升級效果

### 進階作業：技能系統
設計技能冷卻機制

### 挑戰作業：Boss 戰
多階段戰鬥系統

---

## 🎓 評量重點

### 知識面（40%）
- 能解釋具體方法與抽象方法的差異
- 能區分共通邏輯與個別差異
- 理解 DRY 原則

### 技能面（40%）
- 能正確實作方法
- 能設計合理分工

### 應用面（20%）
- 能判斷該用哪種方法
- 能解釋設計決策

---

## 🔄 下週預告

**第三階段：多層繼承結構**

- MeleeRole（近戰角色）
- RangedRole（遠程角色）
- 設計類別階層

---

## ⏰ 時間分配

| 階段 | 時間 | 重點 |
|-----|------|------|
| 引入問題 | 10分鐘 | 重複程式碼 |
| 解決方案 | 15分鐘 | 具體+抽象方法 |
| 實作練習 | 15分鐘 | 動手寫程式 |
| 討論總結 | 10分鐘 | 設計原則 |

---

**教學提示：**
- 重點強調「共通邏輯」vs「個別差異」
- 多用對比和實例
- 給學生充分實作時間
- 鼓勵創意設計
