# 第二階段：混合使用具體方法與抽象方法

## 📚 教學目標

讓學生理解：
1. **抽象類別可以同時擁有具體方法和抽象方法**
2. **如何區分「共通邏輯」與「個別差異」**
3. **具體方法可以呼叫抽象方法的設計模式**
4. **Template Method Pattern 的基本概念**

---

## 🎯 本階段新增內容

### 在 `Role` 抽象類別中新增：

#### 1️⃣ 具體方法：`takeDamage(int damage)`

```java
/**
 * 受到傷害（具體方法）
 * 所有角色受傷的基本流程都相同：
 * 1. 扣除生命值
 * 2. 顯示受傷訊息
 * 3. 檢查是否死亡
 * 4. 如果死亡，呼叫 onDeath()
 */
public void takeDamage(int damage) {
    this.health -= damage;
    System.out.println("💥 " + name + " 受到 " + damage + " 點傷害！目前生命值：" + health);
    
    if (!isAlive()) {
        onDeath(); // 呼叫抽象方法
    }
}
```

#### 2️⃣ 抽象方法：`onDeath()`

```java
/**
 * 死亡時的處理（抽象方法）
 * 每個角色死亡時的表現方式都不同
 */
public abstract void onDeath();
```

#### 3️⃣ 抽象方法：`prepareBattle()` 和 `afterBattle()`

```java
// 戰鬥前的準備動作
public abstract void prepareBattle();

// 戰鬥後的行為
public abstract void afterBattle();
```

---

## 💡 核心概念解說

### 1️⃣ 為什麼 `takeDamage()` 是具體方法？

#### 共通邏輯分析

所有角色受傷時的流程都相同：

```
受到攻擊 → 扣除生命值 → 顯示訊息 → 檢查是否死亡 → (如果死亡) 觸發死亡效果
```

**如果每個子類別都自己實作會有什麼問題？**

```java
// SwordsMan.java - 重複的程式碼
public void takeDamage(int damage) {
    this.health -= damage;
    System.out.println(name + " 受到傷害");
    if (!isAlive()) {
        onDeath();
    }
}

// Magician.java - 幾乎一模一樣
public void takeDamage(int damage) {
    this.health -= damage;  // 重複！
    System.out.println(name + " 受到傷害");  // 重複！
    if (!isAlive()) {  // 重複！
        onDeath();
    }
}
```

❌ **問題：**
- 違反 DRY 原則（Don't Repeat Yourself）
- 如果要修改邏輯，每個類別都要改
- 容易產生不一致的行為

✅ **解決方案：在父類別提供具體方法**

統一在 `Role` 類別實作，所有子類別共用。

---

### 2️⃣ 為什麼 `onDeath()` 是抽象方法？

#### 個別差異分析

每個角色死亡時的表現完全不同：

| 角色類型 | 死亡效果 |
|---------|---------|
| **SwordsMan（劍士）** | 倒下，劍掉落在地 |
| **Magician（魔法師）** | 化為魔法粒子消散 |
| **ShieldSwordsMan（持盾劍士）** | 倒下，盾牌和劍都掉落 |

無法在父類別提供統一實作，必須由子類別各自實作。

---

### 3️⃣ 具體方法呼叫抽象方法：Template Method Pattern

這是 **模板方法模式** 的核心概念：

```java
// 具體方法定義「演算法骨架」
public void takeDamage(int damage) {
    // 步驟 1: 扣血（所有角色相同）
    this.health -= damage;
    
    // 步驟 2: 顯示訊息（所有角色相同）
    System.out.println("受到傷害");
    
    // 步驟 3: 檢查死亡（所有角色相同）
    if (!isAlive()) {
        // 步驟 4: 死亡處理（每個角色不同 - 抽象方法）
        onDeath();
    }
}
```

**優點：**
1. ✅ 父類別控制整體流程
2. ✅ 子類別只需實作差異部分
3. ✅ 確保所有角色遵循相同的流程
4. ✅ 易於維護和擴展

---

## 🔍 設計決策對照表

### 如何判斷該用具體方法還是抽象方法？

| 判斷標準 | 具體方法 | 抽象方法 |
|---------|---------|---------|
| **邏輯是否相同** | ✅ 所有子類別邏輯一致 | ❌ 每個子類別邏輯不同 |
| **能否提供預設實作** | ✅ 可以寫出合理的預設行為 | ❌ 無法寫出通用實作 |
| **是否需要覆寫** | 可選擇性覆寫 | 強制覆寫 |
| **範例** | `takeDamage()`, `isAlive()` | `onDeath()`, `attack()` |

### 實際案例分析

| 方法 | 類型 | 原因 |
|-----|------|------|
| `takeDamage()` | 具體方法 | 所有角色受傷流程相同 |
| `onDeath()` | 抽象方法 | 每個角色死亡效果不同 |
| `prepareBattle()` | 抽象方法 | 每個角色準備方式不同 |
| `afterBattle()` | 抽象方法 | 每個角色戰後行為不同 |
| `isAlive()` | 具體方法 | 所有角色判斷方式相同 |

---

## 🖥️ 執行結果展示

```
════════════════════════════════════════
        🎮 RPG 遊戲 - 第二階段
   展示：具體方法 + 抽象方法的結合
════════════════════════════════════════

⚔️  戰鬥開始！

━━━━━━━━━━ 第 1 回合 ━━━━━━━━━━
🗡️  光明劍士 擦拭劍刃，劍身反射出凜冽的寒光...

⚔️  光明劍士 揮劍攻擊 黑暗法師！
💥 黑暗法師 受到 20 點傷害！目前生命值：60

🗡️  光明劍士 將劍收入劍鞘。

━━━━━━━━━━ 第 2 回合 ━━━━━━━━━━
📖 光明法師 翻開魔法書，開始吟唱古老的咒語...
✨ 魔法能量在周圍凝聚，空氣中閃爍著神秘的光芒。

✨ 光明法師 施放魔法攻擊 黑暗劍士！
💥 黑暗劍士 受到 15 點傷害！目前生命值：85

🧘 光明法師 閉目冥想，恢復消耗的魔力。

[某角色生命值降為 0]

💥 光明法師 受到 25 點傷害！目前生命值：0
💀 光明法師 的生命之火熄滅了...
✨ 光明法師 的身體化為無數魔法粒子，消散在空氣中。
🌟 魔法書掉落在地上，微微發光。
---

════════════════════════════════════════
          🏆 戰鬥結束
════════════════════════════════════════
```

---

## 📝 課堂練習

### 練習 1：理解共通邏輯與個別差異

**問題：** 為什麼 `takeDamage()` 要設計成具體方法，而不是抽象方法？

**參考答案：**
因為所有角色受傷的「基本流程」都相同：扣血 → 顯示訊息 → 檢查死亡。這些步驟對所有角色都一樣，所以可以在父類別統一實作。而「死亡效果」則交給抽象方法 `onDeath()` 處理。

---

### 練習 2：新增升級功能

**任務：** 在 `Role` 類別中新增升級功能

**要求：**
1. 新增具體方法 `levelUp()`：生命值+20，攻擊力+5
2. 新增抽象方法 `onLevelUp()`：每個角色升級時的特殊效果
3. 在各子類別實作 `onLevelUp()`

**參考解答：**

```java
// Role.java
public void levelUp() {
    this.health += 20;
    this.attackPower += 5;
    System.out.println("⭐ " + name + " 升級了！");
    onLevelUp();
}

public abstract void onLevelUp();

// SwordsMan.java
@Override
public void onLevelUp() {
    System.out.println("⚔️  劍技更加精湛！");
}

// Magician.java
@Override
public void onLevelUp() {
    this.healPower += 3;
    System.out.println("✨ 魔法力量增強！治療力 +3");
}
```

---

## 🎓 教學重點總結

### 抽象類別的雙重特性

```
抽象類別 = 具體方法 + 抽象方法
         ↓           ↓
      共通邏輯    個別差異
```

### 設計原則

1. **具體方法**：用於「共通邏輯」
2. **抽象方法**：用於「個別差異」
3. **混合使用**：具體方法呼叫抽象方法（Template Method Pattern）

### 判斷流程

```
需要新增一個方法
        ↓
   所有子類別的邏輯是否相同？
        ↓
    ┌───┴───┐
   是        否
    ↓         ↓
具體方法    抽象方法
```

---

## 🚀 下一階段預告

**第三階段：引入中間抽象類別（多層繼承結構）**

我們將學習：
- 建立 `MeleeRole`（近戰角色）和 `RangedRole`（遠程角色）
- 理解多層抽象類別的繼承關係
- 設計合理的類別階層架構

---

## 📦 檔案清單

```
Stage2_Concrete_And_Abstract/
├── Role.java              # 抽象基礎類別
├── SwordsMan.java         # 劍士類別
├── Magician.java          # 魔法師類別
├── ShieldSwordsMan.java   # 持盾劍士類別
├── RPG.java               # 主程式
├── README.md              # 專案說明
└── 教學流程指南.md        # 教學指南
```

---

## 💻 編譯與執行

```bash
# 編譯
javac *.java

# 執行
java RPG
```

---

## 📌 常見問題 Q&A

### Q1: 具體方法可以呼叫抽象方法嗎？

**A:** 可以！這是 Template Method Pattern 的核心。

### Q2: 為什麼不把所有方法都設計成抽象方法？

**A:** 會產生大量重複程式碼，違反 DRY 原則。

### Q3: 子類別可以覆寫具體方法嗎？

**A:** 可以，但通常不需要。如果需要覆寫，可能代表應該設計成抽象方法。

---

**版本：** Stage 2 - Concrete and Abstract Methods  
**作者：** Chuck  
**更新日期：** 2024
